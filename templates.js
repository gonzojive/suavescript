/*
   Suave's JSTML templating system.
   
   This file contains some functionality for parsing javascript templates.  Javascript
   templates are intended to help generate dynamic content in the same way as templating techniques
   in many other places.

==========================================================================================================   
   This is an overview of the templating tecnniques for generating text/dynamic web content in other
   languages:
   
   I don't know what happened but a whole bunch of a's kind of came out of nowhere :\
   
   Java Server Pages:
      reference: http://www.apl.jhu.edu/~hall/java/Servlet-Tutorial/Servlet-Tutorial-JSP.html#Section2
      aaaaaaaaaaaaaaaaa
         XML version:  <jsp:expression> </>
         Expression is evaluated and placed in output.
      aaaaaaaaaa
         XML version: <jsp:scriptlet> </>
         Code is inserted in service method.
      aaaaaaaaaaa
         XML version: <jsp:declaration> </>
         Code is inserted in body of servlet class, outside of service method.
      aaaaaaaaaaaaaaaaaaaaa
         XML version: <jsp:directive.page> </>
         Directions to the servlet engine about general setup.
      aaaaaaaaaaaaaaaaaaaaa
         XML version: <jsp:directive.include> </>
         Directions to the servlet engine about general setup.
      aaaaaaaaaaaaaaaaa
         XML version: none
         Comment; ignored when JSP page is translated into servlet.
      
      Escaping: <\% inserts plaintext aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
      aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
      aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
      % a line of Ruby code -- treated as aaaaaaaaaa (optional -- see ERB.new)
      %% replaced with % if first thing on a line and % processing is used
      aaaaaaaaaa -- replace with aaaaaaaa respectively
      
      Escaping: aaaaaaaaaa -- replace with aaaaaaaa respectively
      
      All other text is passed through ERB filtering unchanged.
      
      

==========================================================================================================
Namespace issues.
   
   Many of the templating languages out there use overlapping syntax. LSP and JSP use identical syntax,
   except for the XML form of JSP.  This needs to be avoided with a JavaScript template system
   because JavaScript is often generated from templates in other languages.  The flip side of the coin
   is maintaining sweet syntax.
   
   
   [[js
==========================================================================================================
Syntax
   <js%= %js> <js% %js>
      I like this.  <  and > are avoided
   ((js = ))
      
   [[js=  =js]] [[js:  :js]] [[js% %js]] [[js% ]]
      This is also pretty neat.  One advantage is this can be embedded in a lgeal XML page without
      escaping all the <'s and >'s.  JavaScript's own syntax has a lot of comparison signs so this is
      probably a non-issue.  Also, CDATA sections end with ]]>, so this might be a concern if you were
      to use XML to store Suave templates.. consider <option [[js= to_select ? "selected" : "" ]]>
      - a closing tag with a namespace is not as elegant
   {js=  }   {{js:  }}
      syntax similar to this is used in another javascript template system

Perhaps it will be best to support boy 1 and 2.
   
==========================================================================================================
JavaScript templates are intended to be parsable on either the server or the client.
==========================================================================================================
Run-time / Parse-time
   Because Sauve templat

==========================================================================================================
Features
==========================================================================================================
The Context Object and Side Effects.

   When the function generated by the template is being run, it makes sense to hand it information
   to work with as it does whatever it's doing.  It already has some context (through global variables),
   but it may need additional information to render properly.
   
   If you have a User object that has a few fields, maybe email, sex, lastname, favorite_color,
   the page template could take the following form
   
   [[js% var user = this.user ]]
   <div style="background-color: [[js=this.user.favorite_color]];">
      Welcome back, [[js= this.user.sex == 'male' ? 'Mr.' : 'Ms.' ]] [[js= lastname]].
   </div>
   
==========================================================================================================
Dynamic Content

   It is often necessary to write dynamic content once the static HTML has been inserted.  This
   is what the suave super-simple MVC functionality attempts to deal with
*/



var jsescape = function(str) {
   var m = { '\b': '\\b', '\t': '\\t', '\n': '\\n', '\f': '\\f', '\r': '\\r', '"' : '\\"', '\\': '\\\\' }
   if (/["\\\x00-\x1f]/.test(str)) {
     str = str.replace(/([\x00-\x1f\\"])/g, function(a, b) {
         var c = m[b];
         if (c) { return c; }
         c = b.charCodeAt();
         return '\\u00' + Math.floor(c / 16).toString(16) + (c % 16).toString(16);
     });
   }
   return str;
}

var delimited_re = function(open_tok, close_tok, escapechar)
{
   //return open_tok + "((?:(?:.|\\n)(?!" + close_tok + "))*[^\\\\])" + close_tok
   return open_tok + "(" + "(?:" + "[^]" + "(?!" + close_tok + "))*[^\\\\])" + close_tok
}


//returns a function that can be run
var SuaveParser = function(buffer)
{
   var reportError = function(description, type, etc) { throw description; } //we can supplement this to include a line number
   var DEFAULT_OUTVAR = "suaveout"
   var header = "function(){\nvar suaveout='';\n",
       footer = "return suaveout;\n}",
       body = ""
   var plaintext_out_var = DEFAULT_OUTVAR
   var writeRaw = function(text)
   {
      body += text;
   }
   //note, if the idea is to write a string, it needs to come in as a javascript-escaped-and-quoted string
   //already
   var writePlaintext = function(text)
   {
      writeRaw(plaintext_out_var + "+=" + text + "\n");
   }
   //directive form should be somethiing like "do_this: kitty". returns ["do_this", "kitty"]
   //making the regex "[^:]*<OPT_WS>:<OPT_WS>value<OPT_WS>"
   var parseDirective = function(unparsed_directive)
   {
      //we could use negative lookaheads but that's not cross-browser it seems
      var trimStr = function(str) { return str.replace(/^\s*|\s*$/g, '') }
      var md = /^(?:\s*)([^:]*):(?:\s*)(.*)$/i.exec(unparsed_directive)
      return [trimStr(md[1]), trimStr(md[2])]
   }
   var handleDirective = function(unparsed_directive)
   {
      var key_val = parseDirective(unparsed_directive);
      if (!key_val)
         reportError("Syntax error parsing alleged Directive: " + unparsed_directive)
      switch (key_val[0]) //key
      {
         case "capture_to":
            var dc_val = key_val[1].toLowerCase();
            if (dc_val == "default")
               plaintext_out_var = DEFAULT_OUTVAR
            else
               plaintext_out_var = key_val[1]
            break;
         default:
            reportError("Invalid Directive: " + unparsed_directive)
      }
   }
   var suave_expr_regex = new RegExp(delimited_re("\\[\\[js", "\\]\\]", "\\")  + "|" + delimited_re("<js", "js>", "\\"), "g")
   
   Log.msg("regular template expression: " + suave_expr_regex)
   var prev_last_index = 0  //used in the regular expression loop to hold the prevoius
                            //value of suave_expr_regex.lastIndex
   var md_expr              //holds the matchdata from the matched Suave template expression
   var skipped_plaintext='' //text in-between suave expressions
   while (true)
   {
      //Try to match the next expression and break if we fail
      md_expr = suave_expr_regex.exec(buffer)
      if (!md_expr)
         break;
      Log.msg(md_expr)
      
      //read the text we skipped (garbage offset stuff)
      skipped_plaintext = buffer.substring(prev_last_index, suave_expr_regex.lastIndex - md_expr[0].length)
      prev_last_index = suave_expr_regex.lastIndex
      //Add the plaintext to the output buffer
      writePlaintext('"' + jsescape(skipped_plaintext) + '"')
      
      //Extract type of expression from match data
      var e_type = md_expr[1] ? md_expr[1][0] : md_expr[2][0]
      var expr_value = md_expr[1] ? md_expr[1].substring(1) : md_expr[2].substring(1, md_expr[2].length-1)
      
      if (e_type == "=")
         writePlaintext(expr_value + ';\n')
      else if (e_type == "%")
         writeRaw(expr_value);
      else if (e_type == "#");
      else if (e_type == "!")
         handleDirective(expr_value)
      else
         throw "Invalid Suave Expression, " + e_type;
      //body += "Suave Expression: " + md_expr + "\n"
      //Log.msg(expr_re.lastIndex)
   }
   
   writePlaintext('"' + jsescape(buffer.substring(prev_last_index)) + '"')
   
   //Log.msg(expr_re.lastIndex + "; " + body)
   
   Log.msg("TESSSSSSSS");
   
   var func = header + body + footer;
   //Log.msg(func)
   this.js_source = func;
//   Log.msg(eval(func).toSource())
}

